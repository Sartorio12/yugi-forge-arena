-- Create polls table
CREATE TABLE IF NOT EXISTS public.polls (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    news_post_id bigint REFERENCES public.news_posts(id) ON DELETE CASCADE,
    question text NOT NULL,
    poll_type text NOT NULL CHECK (poll_type IN ('user_selection', 'custom')),
    max_votes_per_user int DEFAULT 1,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create poll_options table (for custom text options)
CREATE TABLE IF NOT EXISTS public.poll_options (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    poll_id bigint REFERENCES public.polls(id) ON DELETE CASCADE,
    label text NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create poll_votes table
CREATE TABLE IF NOT EXISTS public.poll_votes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    poll_id bigint REFERENCES public.polls(id) ON DELETE CASCADE,
    user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
    option_id bigint REFERENCES public.poll_options(id) ON DELETE CASCADE, -- for custom options
    candidate_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE, -- for user selection
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT vote_target_check CHECK (
        (option_id IS NOT NULL AND candidate_id IS NULL) OR
        (option_id IS NULL AND candidate_id IS NOT NULL)
    )
);

-- Enable RLS
ALTER TABLE public.polls ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.poll_options ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.poll_votes ENABLE ROW LEVEL SECURITY;

-- Policies
CREATE POLICY "Polls are viewable by everyone" ON public.polls FOR SELECT USING (true);
CREATE POLICY "Admins can manage polls" ON public.polls FOR ALL USING (
  auth.uid() IN (
    SELECT id FROM public.profiles WHERE role IN ('admin', 'organizer')
  )
);

CREATE POLICY "Options are viewable by everyone" ON public.poll_options FOR SELECT USING (true);
CREATE POLICY "Admins can manage options" ON public.poll_options FOR ALL USING (
  auth.uid() IN (
    SELECT id FROM public.profiles WHERE role IN ('admin', 'organizer')
  )
);

CREATE POLICY "Votes are viewable by everyone" ON public.poll_votes FOR SELECT USING (true);
CREATE POLICY "Users can vote" ON public.poll_votes FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own votes" ON public.poll_votes FOR DELETE USING (auth.uid() = user_id);

-- RPC to cast a vote with validation
CREATE OR REPLACE FUNCTION vote_for_poll(
    p_poll_id bigint,
    p_candidate_id uuid DEFAULT NULL,
    p_option_id bigint DEFAULT NULL
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id uuid;
    v_current_votes int;
    v_max_votes int;
    v_poll_type text;
BEGIN
    v_user_id := auth.uid();
    
    -- Check if poll exists and is active
    SELECT max_votes_per_user, poll_type INTO v_max_votes, v_poll_type
    FROM public.polls
    WHERE id = p_poll_id AND is_active = true;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Poll not found or inactive';
    END IF;

    -- Validate input based on type
    IF v_poll_type = 'user_selection' AND p_candidate_id IS NULL THEN
        RAISE EXCEPTION 'Candidate ID required for user selection poll';
    END IF;
    
    IF v_poll_type = 'custom' AND p_option_id IS NULL THEN
        RAISE EXCEPTION 'Option ID required for custom poll';
    END IF;

    -- Check vote count
    SELECT COUNT(*) INTO v_current_votes
    FROM public.poll_votes
    WHERE poll_id = p_poll_id AND user_id = v_user_id;
    
    IF v_current_votes >= v_max_votes THEN
        RAISE EXCEPTION 'You have reached the maximum number of votes for this poll';
    END IF;

    -- Check if already voted for this specific target
    IF EXISTS (
        SELECT 1 FROM public.poll_votes
        WHERE poll_id = p_poll_id 
        AND user_id = v_user_id
        AND (
            (candidate_id = p_candidate_id AND p_candidate_id IS NOT NULL) OR 
            (option_id = p_option_id AND p_option_id IS NOT NULL)
        )
    ) THEN
        RAISE EXCEPTION 'You have already voted for this option';
    END IF;

    -- Insert vote
    INSERT INTO public.poll_votes (poll_id, user_id, candidate_id, option_id)
    VALUES (p_poll_id, v_user_id, p_candidate_id, p_option_id);
END;
$$;

-- RPC to get aggregated results
CREATE OR REPLACE FUNCTION get_poll_results(p_poll_id bigint)
RETURNS TABLE (
    candidate_id uuid,
    option_id bigint,
    vote_count bigint,
    candidate_name text,
    candidate_avatar text,
    option_label text
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        v.candidate_id,
        v.option_id,
        COUNT(v.id) as vote_count,
        p.username as candidate_name,
        p.avatar_url as candidate_avatar,
        o.label as option_label
    FROM public.poll_votes v
    LEFT JOIN public.profiles p ON v.candidate_id = p.id
    LEFT JOIN public.poll_options o ON v.option_id = o.id
    WHERE v.poll_id = p_poll_id
    GROUP BY v.candidate_id, v.option_id, p.username, p.avatar_url, o.label
    ORDER BY vote_count DESC;
END;
$$;
