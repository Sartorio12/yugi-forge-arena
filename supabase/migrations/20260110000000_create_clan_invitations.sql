create type invitation_status as enum ('PENDING', 'ACCEPTED', 'REJECTED', 'CANCELLED');

create table if not exists public.clan_invitations (
    id bigint generated by default as identity primary key,
    clan_id bigint references public.clans(id) on delete cascade not null,
    inviter_id uuid references auth.users(id) on delete cascade not null,
    invitee_id uuid references auth.users(id) on delete cascade not null,
    status invitation_status default 'PENDING'::invitation_status not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS Policies
alter table public.clan_invitations enable row level security;

-- Inviter can see their sent invitations
create policy "Inviter can see their sent invitations"
    on public.clan_invitations for select
    using (auth.uid() = inviter_id);

-- Invitee can see their received invitations
create policy "Invitee can see their received invitations"
    on public.clan_invitations for select
    using (auth.uid() = invitee_id);

-- Clan leaders/strategists can see invitations for their clan
create policy "Clan management can see invitations"
    on public.clan_invitations for select
    using (
        exists (
            select 1 from public.clan_members cm
            where cm.clan_id = clan_invitations.clan_id
            and cm.user_id = auth.uid()
            and cm.role in ('LEADER', 'STRATEGIST')
        )
    );

-- Only leaders/strategists can insert invitations via RPC usually, but enabling insert for safety if needed, restricted by logic
-- Actually, we'll rely on the RPC for the complex logic, but let's keep policy tight.
create policy "Clan management can create invitations"
    on public.clan_invitations for insert
    with check (
        exists (
            select 1 from public.clan_members cm
            where cm.clan_id = clan_invitations.clan_id
            and cm.user_id = auth.uid()
            and cm.role in ('LEADER', 'STRATEGIST')
        )
    );

-- Invitee can update status (accept/reject)
create policy "Invitee can update status"
    on public.clan_invitations for update
    using (auth.uid() = invitee_id);

-- Inviter/Management can cancel/update status
create policy "Management can update status"
    on public.clan_invitations for update
    using (
        exists (
            select 1 from public.clan_members cm
            where cm.clan_id = clan_invitations.clan_id
            and cm.user_id = auth.uid()
            and cm.role in ('LEADER', 'STRATEGIST')
        )
    );

-- RPC to invite user
create or replace function public.invite_user_to_clan(
    p_clan_id bigint,
    p_invitee_id uuid
)
returns void
language plpgsql
security definer
as $$
declare
    v_inviter_role text;
    v_invitee_clan_id bigint;
    v_clan_name text;
    v_inviter_username text;
    v_inviter_avatar text;
    v_invitation_id bigint;
begin
    -- Check if inviter has permission
    select role into v_inviter_role
    from public.clan_members
    where clan_id = p_clan_id and user_id = auth.uid();

    if v_inviter_role is null or v_inviter_role not in ('LEADER', 'STRATEGIST') then
        raise exception 'You do not have permission to invite users to this clan.';
    end if;

    -- Check if invitee is already in a clan
    select clan_id into v_invitee_clan_id
    from public.clan_members
    where user_id = p_invitee_id;

    if v_invitee_clan_id is not null then
        raise exception 'User is already in a clan.';
    end if;

    -- Check for existing pending invitation
    if exists (
        select 1 from public.clan_invitations
        where clan_id = p_clan_id
        and invitee_id = p_invitee_id
        and status = 'PENDING'
    ) then
        raise exception 'User already has a pending invitation to this clan.';
    end if;

    -- Fetch clan name
    select name into v_clan_name from public.clans where id = p_clan_id;
    
    -- Fetch inviter details
    select username, avatar_url into v_inviter_username, v_inviter_avatar 
    from public.profiles 
    where id = auth.uid();

    -- Insert invitation
    insert into public.clan_invitations (clan_id, inviter_id, invitee_id)
    values (p_clan_id, auth.uid(), p_invitee_id)
    returning id into v_invitation_id;

    -- Send notification
    insert into public.notifications (user_id, type, data, link)
    values (
        p_invitee_id, 
        'clan_invitation', 
        jsonb_build_object(
            'clan_id', p_clan_id,
            'clan_name', v_clan_name,
            'inviter_username', v_inviter_username,
            'inviter_avatar_url', v_inviter_avatar,
            'invitation_id', v_invitation_id
        ),
        '/profile/' || auth.uid() -- Link to inviter's profile or maybe clan page? 
        -- Actually, a dedicated invitations page would be best, but for now maybe link to the clan page 
        -- so they can see what clan it is. Or better, just '/clans' if they don't have one?
        -- Let's link to the clan page.
        -- But wait, if they are not a member, they see the public clan page.
        -- That's fine.
    );
    
    -- Update link to clan page
    update public.notifications 
    set link = '/clans/' || p_clan_id
    where user_id = p_invitee_id and type = 'clan_invitation' and (data->>'invitation_id')::bigint = v_invitation_id;

end;
$$;