-- Phase 1: Database and Presence System

-- 1. Add presence columns to profiles
ALTER TABLE public.profiles
ADD COLUMN is_online BOOLEAN NOT NULL DEFAULT false,
ADD COLUMN last_seen TIMESTAMPTZ;

-- 2. Create direct_messages table
CREATE TABLE public.direct_messages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    receiver_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    is_read BOOLEAN NOT NULL DEFAULT false,
    CONSTRAINT content_not_empty CHECK (length(content) > 0)
);

-- 3. Add indexes for performance
CREATE INDEX ON public.direct_messages (sender_id);
CREATE INDEX ON public.direct_messages (receiver_id);
CREATE INDEX ON public.direct_messages (sender_id, receiver_id, created_at DESC);

-- 4. Enable RLS and define policies
ALTER TABLE public.direct_messages ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own messages"
ON public.direct_messages FOR SELECT
TO authenticated
USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

CREATE POLICY "Users can insert their own messages"
ON public.direct_messages FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = sender_id);

CREATE POLICY "Users can update their received messages to mark as read"
ON public.direct_messages FOR UPDATE
TO authenticated
USING (auth.uid() = receiver_id)
WITH CHECK (auth.uid() = receiver_id AND is_read = true);

-- 5. Create RPC function to get conversation list

-- First, define the return type
create type public.conversation_summary as (
    other_user_id uuid,
    username text,
    avatar_url text,
    is_online boolean,
    last_message_content text,
    last_message_at timestamptz,
    unread_count bigint
);

-- Then, create the function
create or replace function public.get_my_conversations()
returns setof public.conversation_summary
language sql
as $$
    select
        p.id as other_user_id,
        p.username,
        p.avatar_url,
        p.is_online,
        (
            select content from public.direct_messages
            where (sender_id = p.id and receiver_id = auth.uid()) or (sender_id = auth.uid() and receiver_id = p.id)
            order by created_at desc limit 1
        ) as last_message_content,
        (
            select created_at from public.direct_messages
            where (sender_id = p.id and receiver_id = auth.uid()) or (sender_id = auth.uid() and receiver_id = p.id)
            order by created_at desc limit 1
        ) as last_message_at,
        (
            select count(*) from public.direct_messages
            where sender_id = p.id and receiver_id = auth.uid() and is_read = false
        ) as unread_count
    from (
        select distinct
            case when sender_id = auth.uid() then receiver_id else sender_id end as user_id
        from public.direct_messages
        where sender_id = auth.uid() or receiver_id = auth.uid()
    ) as conversations
    join public.profiles p on conversations.user_id = p.id
    order by last_message_at desc;
$$;

-- 6. Create RPC function to mark messages as read
CREATE OR REPLACE FUNCTION public.mark_messages_as_read(p_sender_id uuid)
RETURNS void AS $$
BEGIN
    UPDATE public.direct_messages
    SET is_read = true
    WHERE sender_id = p_sender_id AND receiver_id = auth.uid() AND is_read = false;
END;
$$ LANGUAGE plpgsql;
